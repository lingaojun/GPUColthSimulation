# 人物创建功能说明

## 概述
本项目现在支持在场景中创建简单的人物模型，为后续的披风效果实现做准备。

## 文件说明

### 1. Example.cs
- **位置**: `Assets/ClothSimulation/Runtime/Example.cs`
- **功能**: 主要的布料模拟示例类，现在包含人物创建功能
- **特点**: 在启动时自动创建人物，人物会与布料模拟系统一起运行

### 2. CharacterController.cs
- **位置**: `Assets/ClothSimulation/Runtime/CharacterController.cs`
- **功能**: 人物移动控制器
- **特点**: 处理WASD键输入，控制人物移动和旋转

### 3. CharacterTest.cs
- **位置**: `Assets/ClothSimulation/Runtime/CharacterTest.cs`
- **功能**: 独立的人物测试脚本
- **特点**: 可以单独测试人物创建功能，不依赖布料模拟系统

## 使用方法

### 方法一：使用Example.cs（推荐）
1. 在Unity场景中创建一个空的GameObject
2. 将`Example.cs`脚本添加到该GameObject上
3. 在Inspector中设置`ball`参数（拖入一个球体对象）
4. 运行游戏，人物会自动创建

### 方法二：使用CharacterTest.cs（测试用）
1. 在Unity场景中创建一个空的GameObject
2. 将`CharacterTest.cs`脚本添加到该GameObject上
3. 运行游戏，人物会自动创建
4. 或者在Inspector中右键选择"创建测试人物"

## 人物结构

### 身体组成
- **头部**: 球形，位于肩膀上方
- **脖子**: 圆柱形，连接头部和身体
- **肩膀**: 立方体，用于固定披风
- **身体**: 胶囊体，主要躯干
- **左臂**: 上臂、下臂、手部
- **右臂**: 上臂、下臂、手部
- **左腿**: 大腿、小腿、脚部
- **右腿**: 大腿、小腿、脚部

### 人物尺寸
- **总高度**: 约2.5米
- **身体宽度**: 0.8米
- **肩膀宽度**: 1.2米
- **适合测试**: 尺寸适中，便于观察和测试

## 控制说明

### 移动控制
- **W键**: 向前移动
- **S键**: 向后移动
- **A键**: 向左移动
- **D键**: 向右移动
- **自动旋转**: 人物会朝向移动方向

### 物理属性
- **质量**: 1kg
- **阻力**: 5（平滑移动）
- **重力**: 受Unity物理系统影响
- **碰撞**: 身体和头部有碰撞体

## 材质设置

### 默认材质
- **颜色**: 肤色 (0.8, 0.6, 0.4)
- **金属度**: 0.1
- **光滑度**: 0.3
- **着色器**: Standard

### 自定义材质
可以在Inspector中修改`characterMaterial`参数来自定义人物外观。

## 后续扩展

### 披风集成
人物创建完成后，可以：
1. 修改布料模拟系统，将固定点设置在肩膀位置
2. 添加身体碰撞检测
3. 调整布料形状为披风样式

### 动画系统
可以添加：
1. 行走动画
2. 跑步动画
3. 转身动画
4. 其他动作

### 外观优化
可以：
1. 导入更精细的人物模型
2. 添加服装和配饰
3. 添加面部特征
4. 添加头发等细节

## 故障排除

### 常见问题
1. **人物不显示**: 检查相机位置和角度
2. **无法移动**: 检查是否有Rigidbody组件
3. **材质不显示**: 检查Standard着色器是否可用
4. **碰撞异常**: 检查碰撞体设置

### 调试方法
1. 使用CharacterTest.cs进行独立测试
2. 检查Console窗口的错误信息
3. 在Inspector中查看组件设置
4. 使用Scene视图观察人物结构

## 技术细节

### 创建流程
1. 创建根GameObject
2. 添加CharacterController组件
3. 创建各个身体部分
4. 设置材质和碰撞体
5. 配置物理属性

### 性能考虑
- 使用Unity内置Primitive对象，性能良好
- 材质共享，减少Draw Call
- 简单的碰撞体，物理计算效率高

## 下一步
完成人物创建后，可以开始实现披风效果：
1. 修改布料模拟的初始形状
2. 设置肩膀固定点
3. 添加身体碰撞检测
4. 调整物理参数
5. 优化渲染效果
